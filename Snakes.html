<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Open-World Snake RPG</title>
<style>
  :root{--bg:#000;--fg:#fff;}
  html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--fg);font-family:Arial,sans-serif;display:flex;justify-content:center;align-items:center;overflow:hidden;}
  canvas{border:2px solid #fff; display:block; background:#111;}
  .hud{position:absolute;top:10px;left:10px;color:white;font-size:16px;}
</style>
</head>
<body>
<canvas id="game" width="600" height="400" tabindex="0"></canvas>
<div class="hud" id="hud"></div>

<script>
(() => {
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');

const CELL = 20;
const VIEW_WIDTH = Math.floor(canvas.width / CELL);
const VIEW_HEIGHT = Math.floor(canvas.height / CELL);

const MAP_WIDTH = 50;
const MAP_HEIGHT = 50;

// Snake player
let snake = [{x:25, y:25}];
let snakeDir = {x:0, y:0};
let snakeLength = 1;
let playerSkin = 'white';

let points = 0;
let ownedSkins = ['white'];
let items = [];
let npcs = [];
let quests = [];
let keys = {};

// Generate items
for(let i=0;i<50;i++){
    items.push({x:Math.floor(Math.random()*MAP_WIDTH), y:Math.floor(Math.random()*MAP_HEIGHT), type:'apple'});
}

// Generate NPCs
npcs.push({x:10,y:10,name:'Bob',quest:'Collect 5 apples',questItem:'apple',questCount:5,completed:false,collected:0});
npcs.push({x:40,y:35,name:'Alice',quest:'Find the golden skin',questItem:'gold',questCount:1,completed:false,collected:0});

// Camera
let camera = {x:0, y:0};

// Handle keys
window.addEventListener('keydown', e=>{
    keys[e.key]=true;
});
window.addEventListener('keyup', e=>{
    keys[e.key]=false;
});

// Game loop
function gameLoop(){
    handleMovement();
    updateSnake();
    checkItemCollision();
    updateCamera();
    draw();
    updateHUD();
    requestAnimationFrame(gameLoop);
}

// Movement
function handleMovement(){
    if(keys['ArrowUp'] && snakeDir.y===0) snakeDir = {x:0,y:-1};
    if(keys['ArrowDown'] && snakeDir.y===0) snakeDir = {x:0,y:1};
    if(keys['ArrowLeft'] && snakeDir.x===0) snakeDir = {x:-1,y:0};
    if(keys['ArrowRight'] && snakeDir.x===0) snakeDir = {x:1,y:0};
}

// Update snake positions
function updateSnake(){
    if(snakeDir.x===0 && snakeDir.y===0) return;
    const newHead = {x:snake[0].x+snakeDir.x, y:snake[0].y+snakeDir.y};
    // Check walls
    if(newHead.x<0 || newHead.x>=MAP_WIDTH || newHead.y<0 || newHead.y>=MAP_HEIGHT){
        resetGame();
        return;
    }
    // Check self collision
    if(snake.some((seg,i)=>i>0 && seg.x===newHead.x && seg.y===newHead.y)){
        resetGame();
        return;
    }
    snake.unshift(newHead);
    if(snake.length>snakeLength) snake.pop();
}

// Check item collection
function checkItemCollision(){
    items = items.filter(item=>{
        if(item.x===snake[0].x && item.y===snake[0].y){
            points++;
            snakeLength++;
            npcs.forEach(npc=>{
                if(npc.questItem===item.type && !npc.completed){
                    npc.collected++;
                    if(npc.collected>=npc.questCount) npc.completed=true;
                }
            });
            return false;
        }
        return true;
    });
}

// Update camera
function updateCamera(){
    camera.x = snake[0].x - Math.floor(VIEW_WIDTH/2);
    camera.y = snake[0].y - Math.floor(VIEW_HEIGHT/2);
    camera.x = Math.max(0, Math.min(MAP_WIDTH-VIEW_WIDTH, camera.x));
    camera.y = Math.max(0, Math.min(MAP_HEIGHT-VIEW_HEIGHT, camera.y));
}

// Draw
function draw(){
    ctx.fillStyle='#111';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Items
    items.forEach(item=>{
        const dx = (item.x-camera.x)*CELL;
        const dy = (item.y-camera.y)*CELL;
        ctx.fillStyle='red';
        ctx.fillRect(dx+2, dy+2, CELL-4, CELL-4);
    });

    // NPCs
    npcs.forEach(npc=>{
        const dx = (npc.x-camera.x)*CELL;
        const dy = (npc.y-camera.y)*CELL;
        ctx.fillStyle='orange';
        ctx.fillRect(dx+2, dy+2, CELL-4, CELL-4);
    });

    // Snake
    snake.forEach((seg,i)=>{
        const dx = (seg.x-camera.x)*CELL;
        const dy = (seg.y-camera.y)*CELL;
        ctx.fillStyle = i===0 ? playerSkin : `rgb(${220-i*10},${220-i*10},${220-i*10})`;
        ctx.fillRect(dx+1, dy+1, CELL-2, CELL-2);
    });
}

// HUD
function updateHUD(){
    let hudText = `Points: ${points}<br>Skins: ${ownedSkins.join(', ')}<br>`;
    npcs.forEach(npc=>{
        if(Math.abs(snake[0].x-npc.x)<=1 && Math.abs(snake[0].y-npc.y)<=1){
            hudText += `${npc.name}: ${npc.quest} ${npc.completed?"(Completed)":""}<br>`;
        }
    });
    hud.innerHTML = hudText;
}

function resetGame(){
    snake = [{x:25,y:25}];
    snakeDir = {x:0,y:0};
    snakeLength = 1;
    points = 0;
    items = [];
    for(let i=0;i<50;i++){
        items.push({x:Math.floor(Math.random()*MAP_WIDTH), y:Math.floor(Math.random()*MAP_HEIGHT), type:'apple'});
    }
    npcs.forEach(npc=>{
        npc.completed=false;
        npc.collected=0;
    });
}

// Start
gameLoop();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Top-Down Island Shape</title>
<style>
  body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
  canvas { display: block; background: #87CEEB; }
  #inventory { position: absolute; bottom: 10px; left: 10px; display: flex; gap: 5px; }
  .slot { width: 40px; height: 40px; border: 2px solid white; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; cursor: pointer; }
  .selected { border-color: yellow; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="inventory"></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const tileSize = 50;
const worldWidth = 50;
const worldHeight = 50;

// Layers
const groundLayer = [];
const objectLayer = [];
const itemLayer = [];

// Block types/colors
const blockColors = { grass:'#228B22', dirt:'#8B4513', stone:'#808080', tree:'#006400', water:'#1E90FF', sand:'#FFF5BA' };

// Generate island shape using radial falloff + randomness
const centerX = worldWidth/2;
const centerY = worldHeight/2;
const maxDistance = Math.sqrt(centerX**2 + centerY**2);

for(let y=0;y<worldHeight;y++){
  groundLayer[y]=[];
  objectLayer[y]=[];
  itemLayer[y]=[];
  for(let x=0;x<worldWidth;x++){
    const dx = x - centerX;
    const dy = y - centerY;
    let distance = Math.sqrt(dx*dx + dy*dy)/maxDistance; // 0=center, 1=edge
    
    // Add randomness to distance for a wavy island edge
    distance += (Math.random()-0.5)*0.15;

    if(distance>0.85) groundLayer[y][x]='water';
    else if(distance>0.75) groundLayer[y][x]='sand';
    else{
      const r = Math.random();
      if(r<0.1) groundLayer[y][x]='stone';
      else if(r<0.4) groundLayer[y][x]='dirt';
      else groundLayer[y][x]='grass';
    }

    // Object layer (trees)
    if(Math.random()<0.05 && groundLayer[y][x]==='grass') objectLayer[y][x]='tree';
    else objectLayer[y][x]=null;

    // Item layer empty
    itemLayer[y][x]=null;
  }
}

// Player
const player = { x: worldWidth/2*tileSize, y: worldHeight/2*tileSize, width: tileSize*0.8, height: tileSize*0.8, color:'red', speed:6 };

// Camera
const camera = { x:0, y:0, width:canvas.width, height:canvas.height };

// Inventory
let inventory = {};
let selectedSlot = 0;
const inventorySize = 5;
const inventoryEl = document.getElementById('inventory');
function updateInventory(){
  inventoryEl.innerHTML='';
  for(let i=0;i<inventorySize;i++){
    const slot = document.createElement('div');
    slot.className='slot';
    if(i===selectedSlot) slot.classList.add('selected');
    slot.textContent = inventory[i] || '';
    slot.onclick = ()=>{ selectedSlot=i; updateInventory();}
    inventoryEl.appendChild(slot);
  }
}
updateInventory();

// Controls
const keys = {};
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// Mouse interaction
canvas.addEventListener('mousedown', e=>{
  const mx = e.clientX + camera.x;
  const my = e.clientY + camera.y;
  const tileX = Math.floor(mx/tileSize);
  const tileY = Math.floor(my/tileSize);

  if(e.button===0){ // mine
    let minedBlock = null;
    if(itemLayer[tileY]?.[tileX]) { minedBlock=itemLayer[tileY][tileX]; itemLayer[tileY][tileX]=null; }
    else if(objectLayer[tileY]?.[tileX]) { minedBlock=objectLayer[tileY][tileX]; objectLayer[tileY][tileX]=null; }
    else if(groundLayer[tileY]?.[tileX] && groundLayer[tileY][tileX]!=='water') { minedBlock=groundLayer[tileY][tileX]; groundLayer[tileY][tileX]='sand'; }

    if(minedBlock){
      const slotIndex = Object.keys(inventory).length<inventorySize ? Object.keys(inventory).length : selectedSlot;
      inventory[slotIndex] = minedBlock;
      updateInventory();
    }

  } else if(e.button===2){ // place
    const block = inventory[selectedSlot];
    if(block && itemLayer[tileY]?.[tileX]===null && groundLayer[tileY][tileX]!=='water'){
      itemLayer[tileY][tileX]=block;
      inventory[selectedSlot]=null;
      updateInventory();
    }
  }
});
canvas.oncontextmenu = e=>e.preventDefault();

// Game loop
function update(){
  let dx=0, dy=0;
  if(keys['w']) dy=-player.speed;
  if(keys['s']) dy=player.speed;
  if(keys['a']) dx=-player.speed;
  if(keys['d']) dx=player.speed;

  player.x += dx;
  player.y += dy;

  // Keep player inside world
  player.x = Math.max(0, Math.min(worldWidth*tileSize-player.width, player.x));
  player.y = Math.max(0, Math.min(worldHeight*tileSize-player.height, player.y));

  // Camera follows player
  camera.x = player.x + player.width/2 - canvas.width/2;
  camera.y = player.y + player.height/2 - canvas.height/2;

  draw();
  requestAnimationFrame(update);
}

// Draw function
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const startCol = Math.floor(camera.x/tileSize);
  const endCol = startCol + Math.ceil(canvas.width/tileSize)+1;
  const startRow = Math.floor(camera.y/tileSize);
  const endRow = startRow + Math.ceil(canvas.height/tileSize)+1;

  for(let y=startRow;y<endRow;y++){
    for(let x=startCol;x<endCol;x++){
      const drawX = x*tileSize - camera.x;
      const drawY = y*tileSize - camera.y;

      // Draw layers
      if(groundLayer[y]?.[x]) { ctx.fillStyle = blockColors[groundLayer[y][x]]; ctx.fillRect(drawX, drawY, tileSize, tileSize); ctx.strokeRect(drawX, drawY, tileSize, tileSize); }
      if(objectLayer[y]?.[x]) { ctx.fillStyle = blockColors[objectLayer[y][x]]; ctx.fillRect(drawX, drawY, tileSize, tileSize); ctx.strokeRect(drawX, drawY, tileSize, tileSize); }
      if(itemLayer[y]?.[x]) { ctx.fillStyle = blockColors[itemLayer[y][x]]; ctx.fillRect(drawX, drawY, tileSize, tileSize); ctx.strokeRect(drawX, drawY, tileSize, tileSize); }
    }
  }

  // Draw player
  const px = player.x - camera.x;
  const py = player.y - camera.y;
  ctx.fillStyle = player.color;
  ctx.fillRect(px, py, player.width, player.height);
}

update();
</script>
</body>
</html>

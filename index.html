<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Doom Dungeon Crawler - Sword Combat</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const tileSize = 64;
const mapWidth = 20;
const mapHeight = 15;

// Map generation
const map = Array.from({length: mapHeight},()=>Array(mapWidth).fill(1));
function createRoom(){
  const w = 3 + Math.floor(Math.random()*4);
  const h = 3 + Math.floor(Math.random()*4);
  const x = 1 + Math.floor(Math.random()*(mapWidth-w-1));
  const y = 1 + Math.floor(Math.random()*(mapHeight-h-1));
  for(let i=y;i<y+h;i++)
    for(let j=x;j<x+w;j++)
      map[i][j]=0;
  return {x:x+Math.floor(w/2), y:y+Math.floor(h/2)};
}
const rooms = [];
for(let i=0;i<4;i++) rooms.push(createRoom());
function createCorridor(a,b){
  let x=a.x, y=a.y;
  while(x!==b.x){ map[y][x]=0; x+=x<b.x?1:-1; }
  while(y!==b.y){ map[y][x]=0; y+=y<b.y?1:-1; }
}
for(let i=0;i<rooms.length-1;i++) createCorridor(rooms[i],rooms[i+1]);

// Player
let player = {x:rooms[0].x*tileSize, y:rooms[0].y*tileSize, angle:0, speed:1.2};

// Enemies
const enemies = [];
for(let i=1;i<rooms.length;i++) enemies.push({x:rooms[i].x*tileSize, y:rooms[i].y*tileSize, hp:3});

// Controls
const keys={};
document.addEventListener('keydown',e=>keys[e.key]=true);
document.addEventListener('keyup',e=>keys[e.key]=false);

// Sword
let swordCooldown=0;
document.addEventListener('keydown',e=>{
  if(e.key===' ' && swordCooldown<=0){
    swordCooldown=20;
    const range=120; // increased sword range
    enemies.forEach(enemy=>{
      const dx=enemy.x-player.x;
      const dy=enemy.y-player.y;
      const dist=Math.hypot(dx,dy);
      const angleToEnemy=Math.atan2(dy,dx);
      let diff=angleToEnemy-player.angle;
      diff=Math.atan2(Math.sin(diff),Math.cos(diff));
      if(dist<range && Math.abs(diff)<Math.PI/6) enemy.hp-=1;
    });
  }
});

function movePlayer(){
  let newX=player.x;
  let newY=player.y;
  if(keys['ArrowUp']){ newX+=Math.cos(player.angle)*player.speed; newY+=Math.sin(player.angle)*player.speed; }
  if(keys['ArrowDown']){ newX-=Math.cos(player.angle)*player.speed; newY-=Math.sin(player.angle)*player.speed; }
  if(keys['ArrowLeft']) player.angle-=0.04;
  if(keys['ArrowRight']) player.angle+=0.04;

  const left=Math.floor(newX/tileSize), top=Math.floor(newY/tileSize);
  if(map[top] && map[top][left]===0){ player.x=newX; player.y=newY; }
}

// Raycasting walls
function castRays(){
  const fov=Math.PI*2/3;
  const numRays=300;
  const rayWidth=canvas.width/numRays;
  for(let i=0;i<numRays;i++){
    const rayAngle=(player.angle-fov/2)+(i/numRays)*fov;
    let distance=0; let hit=false;
    const sin=Math.sin(rayAngle), cos=Math.cos(rayAngle);
    while(!hit && distance<800){
      distance+=1;
      const testX=Math.floor((player.x+cos*distance)/tileSize);
      const testY=Math.floor((player.y+sin*distance)/tileSize);
      if(map[testY] && map[testY][testX]===1) hit=true;
    }
    const shade=255-Math.min(distance*0.5,200);
    ctx.fillStyle=`rgb(${shade},${shade},${shade})`;
    const wallHeight=(tileSize*300)/distance;
    ctx.fillRect(i*rayWidth,(canvas.height/2)-wallHeight/2,rayWidth+1,wallHeight);
  }
}

// Draw enemies and sword
function drawOverlay(){
  enemies.forEach(enemy=>{
    if(enemy.hp<=0) return;
    const dx=enemy.x-player.x;
    const dy=enemy.y-player.y;
    const dist=Math.hypot(dx,dy);
    const angleToEnemy=Math.atan2(dy,dx);
    let diff=angleToEnemy-player.angle;
    diff=Math.atan2(Math.sin(diff),Math.cos(diff));

    // Line-of-sight check
    let visible=true;
    const steps=Math.floor(dist);
    for(let s=0;s<steps;s+=5){
      const testX=Math.floor((player.x+Math.cos(player.angle)*s)/tileSize);
      const testY=Math.floor((player.y+Math.sin(player.angle)*s)/tileSize);
      if(map[testY] && map[testY][testX]===1){ visible=false; break; }
    }

    if(visible && Math.abs(diff)<Math.PI/6){
      const size=(tileSize*300)/dist*0.6; // scale enemies more
      const screenX=(canvas.width/2)+(diff/(Math.PI/3))*(canvas.width/2);
      ctx.fillStyle='red';
      ctx.fillRect(screenX-size/2,(canvas.height/2)-size/2,size,size);
    }
  });

  // Sword swing
  if(swordCooldown>0){
    const swingProgress=(20-swordCooldown)/10; // 0-1
    const swordLength=180; // longer sword
    const swordWidth=25;
    const angleOffset=(Math.PI/4)*(1-swingProgress);
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height*0.75);
    ctx.rotate(-angleOffset);
    const grad=ctx.createLinearGradient(0,0,swordWidth,-swordLength);
    grad.addColorStop(0,'silver'); grad.addColorStop(1,'white');
    ctx.fillStyle=grad;
    ctx.fillRect(-swordWidth/2, -swordLength, swordWidth, swordLength);
    ctx.restore();
  }
}

function gameLoop(){
  ctx.fillStyle='rgb(70,70,70)'; ctx.fillRect(0,0,canvas.width,canvas.height/2);
  ctx.fillStyle='rgb(50,50,50)'; ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);

  movePlayer();
  castRays();
  drawOverlay();

  if(swordCooldown>0) swordCooldown--;
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>

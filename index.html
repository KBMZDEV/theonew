document.write(`
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Snake — Chromebook</title>
<style>
  :root{--bg:#000;--fg:#fff;--box:#111}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Arial,Helvetica,sans-serif}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;padding:24px;box-sizing:border-box}
  h1{margin:0;font-size:1.6rem}
  .game-card{background:var(--box);border:2px solid var(--fg);padding:12px;border-radius:10px;display:inline-block}
  .top-row{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:10px}
  #score{font-weight:700}
  canvas{display:block;background:#0b0b0b;border-radius:6px}
  .controls{font-size:0.9rem;opacity:0.9;margin-top:8px}
  button{background:transparent;color:var(--fg);border:1px solid var(--fg);padding:6px 10px;border-radius:6px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .small{font-size:0.9rem;opacity:0.9}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Snake — small demo</h1>
    <div class="game-card" role="application" aria-label="Snake game">
      <div class="top-row">
        <div class="small">Score: <span id="score">0</span></div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="restartBtn">Restart</button>
          <div class="small" id="status">Playing</div>
        </div>
      </div>
      <canvas id="game" width="300" height="300" tabindex="0"></canvas>
      <div class="controls small">Controls: ↑↓←→ or WASD. Space = pause</div>
    </div>
    <div class="small" style="opacity:0.85">Tip: click the canvas then use the keys.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const statusEl = document.getElementById('status');
  const restartBtn = document.getElementById('restartBtn');

  const CELL_SIZE = 15;            // pixel size of one cell
  const COLS = canvas.width / CELL_SIZE; // 20
  const ROWS = canvas.height / CELL_SIZE; // 20
  const MOVE_INTERVAL = 120;      // ms between moves (speed)

  let snake, dir, nextDir, food, timer, running, score;

  function randPos() {
    return { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
  }

  function placeFood() {
    let p;
    do {
      p = randPos();
    } while (snake.some(s => s.x===p.x && s.y===p.y));
    food = p;
  }

  function startGame() {
    snake = [{x:10,y:10},{x:9,y:10},{x:8,y:10}];
    dir = {x:1,y:0}; // moving right
    nextDir = dir;
    score = 0;
    placeFood();
    running = true;
    statusEl.textContent = 'Playing';
    scoreEl.textContent = score;
    if (timer) clearInterval(timer);
    timer = setInterval(tick, MOVE_INTERVAL);
    draw();
  }

  function pauseToggle() {
    if (!running) return; // if not started, ignore
    if (timer) { clearInterval(timer); timer = null; statusEl.textContent = 'Paused'; }
    else { timer = setInterval(tick, MOVE_INTERVAL); statusEl.textContent = 'Playing'; }
  }

  function gameOver() {
    running = false;
    if (timer) { clearInterval(timer); timer = null; }
    statusEl.textContent = 'Game Over';
    // flash effect
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function tick() {
    // apply buffered direction change (prevents 180-turn)
    if ((nextDir.x !== -dir.x || nextDir.y !== -dir.y) || snake.length===1) dir = nextDir;

    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

    // wrap-around (optional). Use wrap; if you want wall collision, change to gameOver on out-of-bounds.
    function tick() {
  // apply buffered direction change (prevents 180-turn)
  if ((nextDir.x !== -dir.x || nextDir.y !== -dir.y) || snake.length===1) dir = nextDir;

  const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

  // wall collision check
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
    gameOver();
    draw();
    return;
  }

  // collision with self?
  if (snake.some(s => s.x===head.x && s.y===head.y)) { 
    gameOver(); 
    draw(); 
    return; 
  }

  snake.unshift(head);

  // eat food?
  if (head.x===food.x && head.y===food.y) {
    score += 1;
    scoreEl.textContent = score;
    placeFood();
  } else {
    snake.pop();
  }

  draw();
}


    // collision with self?
    if (snake.some(s => s.x===head.x && s.y===head.y)) { gameOver(); draw(); return; }

    snake.unshift(head);

    // eat food?
    if (head.x===food.x && head.y===food.y) {
      score += 1;
      scoreEl.textContent = score;
      placeFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function draw() {
    // background
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid optional faint (disabled for cleaner look)
    // ctx.strokeStyle = '#0f0f0f';
    // for (let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*CELL_SIZE,0);ctx.lineTo(x*CELL_SIZE,canvas.height);ctx.stroke()}
    // for (let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*CELL_SIZE);ctx.lineTo(canvas.width,y*CELL_SIZE);ctx.stroke()}

    // draw food
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(food.x*CELL_SIZE+2, food.y*CELL_SIZE+2, CELL_SIZE-4, CELL_SIZE-4);

    // draw snake
    for (let i=0;i<snake.length;i++){
      const s = snake[i];
      // gradient from head to tail
      const t = i/(snake.length||1);
      const shade = Math.round(220 - t*140); // 220 -> 80
      ctx.fillStyle = 'rgb('+shade+','+shade+','+shade+')';
      ctx.fillRect(s.x*CELL_SIZE+1, s.y*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2);
      // head accent
      if (i===0) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(s.x*CELL_SIZE+4, s.y*CELL_SIZE+4, CELL_SIZE-8, CELL_SIZE-8);
      }
    }
  }

  // keyboard input
  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (!running && k !== ' ') return;
    if (k === 'ArrowUp' || k==='w' || k==='W') nextDir = {x:0,y:-1};
    else if (k === 'ArrowDown' || k==='s' || k==='S') nextDir = {x:0,y:1};
    else if (k === 'ArrowLeft' || k==='a' || k==='A') nextDir = {x:-1,y:0};
    else if (k === 'ArrowRight' || k==='d' || k==='D') nextDir = {x:1,y:0};
    else if (k === ' '){ e.preventDefault(); pauseToggle(); }
  });

  // ensure canvas is focusable and focused so keys work on first click
  canvas.addEventListener('click', ()=>{ canvas.focus(); });
  canvas.setAttribute('tabindex','0');

  restartBtn.addEventListener('click', startGame);

  // start automatically
  startGame();
})();
</script>
</body>
</html>
`);
